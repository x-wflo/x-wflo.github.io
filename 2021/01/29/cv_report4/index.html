<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  
  
  
  <meta name="description" content="作业堆积地，计女一个。">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    opencv实现Eigenface人脸识别 |
    
    Invictus maneo</title>
  
  <link rel="shortcut icon" href="/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-cv_report4" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h1 class="article-title" itemprop="name">
  opencv实现Eigenface人脸识别
</h1>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/01/29/cv_report4/" class="article-date">
  <time datetime="2021-01-29T14:36:31.000Z" itemprop="datePublished">2021-01-29</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/">课程作业</a>
</div>

    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>自己用opencv实现EigenFace 人脸识别的训练与识别、与重构过程。</p>
<span id="more"></span>
<h2 id="实验目的和要求"><a href="#实验目的和要求" class="headerlink" title="实验目的和要求"></a>实验目的和要求</h2><hr>
<p>自己写代码实现EigenFace 人脸识别的训练与识别、与重构过程，要求如下：</p>
<ol>
<li><p>假设每张⼈脸图像只有一张人脸，且两只眼睛位置已知（即可人工标注给出）。每张图像的眼睛位置存在相应目录下的㇐个与图像文件名相同但后缀名为txt的⽂本文件⾥，文本文件中用一行、以空格分隔的4个数字表示，分别对应于两只眼睛中⼼在图像中的位置；</p>
</li>
<li><p>实现三个程序过程，分别对应训练与识别、重构。</p>
</li>
<li><p>自己构建一个人脸库（至少40个，包括自己），课程主页提供一个AT&amp;T人脸库可选用。</p>
</li>
<li><p>不能直接调用OpenCV里面与Eigenface相关的一些函数，所有关键函数需要自己实现。</p>
<p>特征值与特征向量求解函数可以调用SDK;</p>
</li>
</ol>
<h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><hr>
<p><strong>Eigenface人脸识别实现步骤：</strong></p>
<ol>
<li>对训练集内所有人脸图像作归一化处理；</li>
<li>通过PCA计算获得一组特征向量(特征脸)。通常一百个特征向量就足够；</li>
<li>将每幅人脸图像都投影到由该组特征脸张成的 子空间中，得到在该子空间坐标；</li>
<li>对输入的一幅待测图像，归一化后，将其映射到特征脸子空间中。然后用某种距离度量来描 述两幅人脸图像的相似性，如欧氏距离。</li>
</ol>
<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><ul>
<li><p>确定模板</p>
</li>
<li><p>对灰度值做归一化</p>
<p>通常我们使用两种方法来增强图片的对比度：</p>
<ul>
<li><p>直方图均衡化</p>
<p>OpenCV提供了一个易用的函数，用于直方图均衡化处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Equalizes the histogram of a grayscale image.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">equalizeHist</span><span class="params">(InputArray src, OutputArray dst)</span></span></span><br></pre></td></tr></table></figure>
<p>实现原理：一个完全均衡的直方图，意味着所有箱子包含的像素数量是相同的。其中一个必要条件就是，50%像素的强度值小于128，25%像素的强度值小于64，依次类推。</p>
</li>
<li><p>直方图拉伸</p>
<p>直方图拉伸让像素尽可能分布在[0,255]的范围之内。</p>
</li>
</ul>
</li>
</ul>
<h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><h4 id="PCA原理"><a href="#PCA原理" class="headerlink" title="PCA原理"></a>PCA原理</h4><p>PCA全名为主成分分析，其主要目的就是寻找一个矩阵，然后把原来的一组带有相关性的矩阵映射到寻找到的那个矩阵中，达到降维的目的。</p>
<p><strong>一般的，如果我们有M个N维向量，想将其变换为由R个N维向量表示的新空间中，那么首先将R个基按行组成矩阵A，然后将向量按列组成矩阵B，那么两矩阵的乘积AB就是变换结果，其中AB的第m列为A中第m列变换后的结果。</strong> </p>
<p>这句话就相当于找到了一个R行N列矩阵，然后乘一个N行M列矩阵，这样就得到了一个R行M列矩阵（其中R&lt;=N），达到降维的目的。其中M和N的含义为，M可以代表样本个数，而N代表每个样本的特征个数，所以最终结果就是把原来N个特征变为了R个特征，达到降维目的。  </p>
<h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><ol>
<li><p>构建样本合集。读入MxN​大小的人脸，并把图片矩阵转换为1xMN​大小的矩阵。计总共读入$K$张人脸，那最后将所有1xMN的矩阵合并后，我们得到了kxMN​的矩阵$T$。</p>
</li>
<li><p>对矩阵$T$计算矩阵的均值向量，我们称均值向量为训练人脸集的平均脸。对矩阵$T$减去其平均脸，我们能得到每个人脸对于平均脸的差异。</p>
</li>
<li><p>计算协方差矩阵<strong>S</strong>的特征值和特征向量。每一个特征向量的维数与原始图像的一致，因此可以被看作是一个图像。因此这些向量被称作特征脸。他们代表了图像与均值图像差别的不同方向。</p>
<p>通常来说，这个过程的计算代价很高。对于一个NxN（比如100x100）维的图像来说，上述直接计算其特征向量，其协方差矩阵可以达到10000x10000，需要耗费大量的计算时间。因此有了如下的简单计算。</p>
<p>如果训练图像的数量小于图像的维数比如$(M&lt;N^2)$，那么起作用的特征向量只有$M-1$个而不是$N^2$个（因为其他的特征向量对应的特征值为0），所以求解特征向量我们只需要求解一个$N*N$的矩阵。每个特征向量还原成像素排列就成为特征脸。</p>
<p>但是在实际操作中发现，该方法会导致人脸重构的失败，不知是否是对于公式理解的不透彻，没有找到解决方法。</p>
</li>
<li><p>选择主成分。一个$D * D$的协方差矩阵会产生$D$个特征向量，每一个对应$M × N$图像空间中的一个方向。具有较大特征值的特征向量会被保留下来，一般选择最大的N个，或者按照特征值的比例进行保存，如保留前95%。</p>
</li>
</ol>
<h3 id="人脸识别"><a href="#人脸识别" class="headerlink" title="人脸识别"></a>人脸识别</h3><p>对于人脸样本$f$来说，我们需要做的就是将样本映射到特征脸集的空间上。公式为：</p>
<script type="math/tex; mode=display">
y_f=A^Tf</script><p>$y_f$是一组向量，表示在各个特征脸上，输入样本的权重。A为特征脸矩阵。</p>
<p>于此再求得训练人脸样本中，和测试样本差异最小的样本，一般使用欧氏距离来判断最短。此时我们认为此样本是所求的识别对象。</p>
<script type="math/tex; mode=display">
Distance_k=||Ω-Ω_k||^2</script><p>其中Ω为映射后的人脸样本，$Ω_k$是训练集中的某张人脸。</p>
<h3 id="人脸重构"><a href="#人脸重构" class="headerlink" title="人脸重构"></a>人脸重构</h3><p>在用特征脸对输入人脸样本进行标志得到权重向量后，我们也可以通过权重向量和特征脸来进行输入样本的人脸的重构。</p>
<p>有：</p>
<script type="math/tex; mode=display">
y_f=A^Tf</script><p>则：</p>
<script type="math/tex; mode=display">
f^0=Ay_f</script><p>人脸重构的效果和使用特征脸的张数有关，一般来说，当人脸重构时使用的特征脸张数越多，结果与原输入图片越相近。</p>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><hr>
<ul>
<li><p>opencv</p>
</li>
<li><p>python</p>
</li>
</ul>
<h2 id="实验具体实现"><a href="#实验具体实现" class="headerlink" title="实验具体实现"></a>实验具体实现</h2><hr>
<h4 id="预处理与构建矩阵"><a href="#预处理与构建矩阵" class="headerlink" title="预处理与构建矩阵"></a>预处理与构建矩阵</h4><p>构建人脸类，用于预处理（人眼对其，直方图均衡化）和将一张人脸图片输入成为MN*1的矩阵。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#人脸类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Face</span>():</span></span><br><span class="line">    /*省略*/</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, file_path, eyes_path</span>):</span></span><br><span class="line">        self.load_eyes(eyes_path)</span><br><span class="line">        self.file = file_path</span><br><span class="line">        self.eye = eyes_path</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_eyes</span>(<span class="params">self, file_path</span>):</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            string = f.read()</span><br><span class="line">            a = string.split()</span><br><span class="line">            self.x1 = <span class="built_in">int</span>(a[<span class="number">0</span>])</span><br><span class="line">            self.y1 = <span class="built_in">int</span>(a[<span class="number">1</span>])</span><br><span class="line">            self.x2 = <span class="built_in">int</span>(a[<span class="number">2</span>])</span><br><span class="line">            self.y2 = <span class="built_in">int</span>(a[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transform</span>(<span class="params">self</span>):</span>  <span class="comment"># 对齐+转换为矩阵</span></span><br><span class="line"></span><br><span class="line">        image = cv.imread(self.file, cv.IMREAD_GRAYSCALE)</span><br><span class="line">        <span class="comment"># 对齐 定位</span></span><br><span class="line">        point_x = (self.x1 + self.x2) / <span class="number">2</span></span><br><span class="line">        point_y = (self.y1 + self.y2) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        angle = math.atan(<span class="built_in">float</span>(self.y1 - self.y2) / <span class="built_in">float</span>(self.x1 - self.x2)) * <span class="number">180</span> / PI</span><br><span class="line">        trans = cv.getRotationMatrix2D((point_x, point_y), angle, <span class="number">1.0</span>)</span><br><span class="line">        trans[<span class="number">0</span>][<span class="number">2</span>] += <span class="number">55</span> - point_x</span><br><span class="line">        trans[<span class="number">1</span>][<span class="number">2</span>] += <span class="number">30</span> - point_y</span><br><span class="line"></span><br><span class="line">        image = cv.warpAffine(image, trans, image.shape)  <span class="comment"># 眼睛定位，映射</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 归一，直方图均衡化</span></span><br><span class="line">        transform_pic = cv.resize(image, IMAGE_SIZE)</span><br><span class="line"></span><br><span class="line">        hist = cv.equalizeHist(transform_pic)</span><br><span class="line">        self.vect = hist.reshape(hist.size, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.vect</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#构建人脸数据集</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDatabase</span>(<span class="params">path</span>):</span></span><br><span class="line">    <span class="comment"># 查看文件</span></span><br><span class="line">    <span class="keyword">global</span> T</span><br><span class="line">    <span class="comment">#A&amp;AT训练集，用的是pgm格式图片</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, train_num + <span class="number">1</span>):</span><br><span class="line">        person_path = path + <span class="string">&#x27;/s&#x27;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, file_num + <span class="number">1</span>):</span><br><span class="line">            face_path = person_path + <span class="string">&#x27;/&#x27;</span> + <span class="built_in">str</span>(j) + <span class="string">&#x27;.pgm&#x27;</span></span><br><span class="line">            eyes_path = person_path + <span class="string">&#x27;/&#x27;</span> + <span class="built_in">str</span>(j) + <span class="string">&#x27;.txt&#x27;</span></span><br><span class="line">            faces = Face(face_path, eyes_path)</span><br><span class="line">            T.append(faces.transform())</span><br><span class="line">            face_list.append(faces)</span><br><span class="line">	</span><br><span class="line">    <span class="comment">#自己的人脸集，用的是JPG格式图片</span></span><br><span class="line">    path_own = path + <span class="string">&#x27;/s41&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, file_num + <span class="number">1</span>):</span><br><span class="line">        face_path = path_own + <span class="string">&#x27;/&#x27;</span> + <span class="built_in">str</span>(j) + <span class="string">&#x27;.jpg&#x27;</span></span><br><span class="line">        eyes_path = path_own + <span class="string">&#x27;/&#x27;</span> + <span class="built_in">str</span>(j) + <span class="string">&#x27;.txt&#x27;</span></span><br><span class="line">        faces2 = Face(face_path, eyes_path)</span><br><span class="line">        T.append(faces2.transform())</span><br><span class="line">        face_list.append(faces2)</span><br><span class="line"></span><br><span class="line">    T = np.array(T)</span><br><span class="line">    T = T.reshape(T.shape[<span class="number">0</span>], T.shape[<span class="number">1</span>])</span><br><span class="line">    <span class="comment">#形成MN*k的人脸矩阵</span></span><br><span class="line">    <span class="keyword">return</span> np.mat(T).T</span><br></pre></td></tr></table></figure>
<h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p><strong>可视化界面：</strong></p>
<p>可视化界面主要用于选择特征脸能量的百分比，从而确定使用多少张特征脸来进行识别。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gui</span>():</span></span><br><span class="line">    root = tk.Tk()</span><br><span class="line">    root.title(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">    root.geometry(<span class="string">&#x27;500x300&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    l = tk.Label(root)</span><br><span class="line">    l.config(text=<span class="string">&quot;选择能量百分比值&quot;</span>)</span><br><span class="line">    l.pack()</span><br><span class="line">    s1 = tk.Scale(root, from_=<span class="number">0.1</span>, to=<span class="number">1</span>,resolution=<span class="number">0.01</span>,orient=tk.HORIZONTAL)  <span class="comment"># Scale组件</span></span><br><span class="line">    s1.pack()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">select</span>():</span></span><br><span class="line">        f=s1.get()</span><br><span class="line">        btn.pack_forget()</span><br><span class="line">        example(f)</span><br><span class="line">        root.mainloop()</span><br><span class="line"></span><br><span class="line">    btn = tk.Button(root, text=<span class="string">&quot;开始训练&quot;</span>, command=<span class="keyword">lambda</span>:select())</span><br><span class="line">    btn.pack()</span><br><span class="line"></span><br><span class="line">    root.mainloop()</span><br></pre></td></tr></table></figure>
<p>关于人脸训练集T，我们使用<code>np.cov</code>矩阵来得到其协方差矩阵。</p>
<p>由于速度问题和函数限制问题，我们统一将输入的图片全部修改为50*50的尺寸大小，从而获得更快的计算速度。</p>
<p>计算协方差矩阵的特征值和特征向量时，我们使用<code>np.linalg.eigh</code>函数。该函数返回两个对象，一个包含矩阵的特征值的<em>一</em>维数组，以及一个对应的特征向量（以列为单位）的矩阵。相比于<code>np.linalg.eig</code>函数，<code>np.linalg.eigh</code>的好处是使用更加快速的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#均值矩阵(平均脸)</span></span><br><span class="line">   mean = T.mean(axis=<span class="number">1</span>)  </span><br><span class="line">   <span class="comment">#计算每张图和平均脸的差值</span></span><br><span class="line">   A = T - mean</span><br><span class="line"></span><br><span class="line">   <span class="comment">#平均脸输出</span></span><br><span class="line">   aver = mean.reshape(IMAGE_SIZE)</span><br><span class="line">   aver = np.uint8(aver)</span><br><span class="line">   cv.imwrite(<span class="string">&quot;meanface.jpg&quot;</span>, aver)</span><br><span class="line">   meanface = cv.imread(<span class="string">&quot;meanface.jpg&quot;</span>)</span><br><span class="line">   cv.imshow(<span class="string">&quot;meanface&quot;</span>, meanface)</span><br><span class="line"></span><br><span class="line">   <span class="comment">#求协方差矩阵特征向量与特征值</span></span><br><span class="line">   cov = np.cov(T, rowvar=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">   eigen_value, eigen_vect = np.linalg.eigh(cov)</span><br><span class="line">   <span class="comment">#按照能量值进行排序</span></span><br><span class="line">   <span class="built_in">sorted</span> = np.argsort(eigen_value[::-<span class="number">1</span>])</span><br><span class="line">   eigen_value = eigen_value[<span class="built_in">sorted</span>]</span><br><span class="line">   eigen_vect = eigen_vect[:, <span class="built_in">sorted</span>]</span><br><span class="line"></span><br><span class="line">   <span class="comment">#根据能量值确定使用多少张特征脸</span></span><br><span class="line">   energy_total = <span class="built_in">sum</span>(eigen_value)</span><br><span class="line">   energy_level = energy_f * energy_total</span><br><span class="line">   energy = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(eigen_value.shape[<span class="number">0</span>]):</span><br><span class="line">       energy = energy + eigen_value[i]</span><br><span class="line">       <span class="keyword">if</span> energy &gt; energy_level:</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;PC_NUM&quot;</span>, i)</span><br><span class="line">   PC_num = i</span><br><span class="line">   eigenface = eigen_vect[:, <span class="number">0</span>:PC_num]</span><br><span class="line"></span><br><span class="line">   <span class="comment">#保存训练数据集</span></span><br><span class="line">   np.save(<span class="string">&#x27;data.npy&#x27;</span>, eigenface)</span><br><span class="line">   np.save(<span class="string">&#x27;mean.npy&#x27;</span>, mean)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="识别"><a href="#识别" class="headerlink" title="识别"></a>识别</h4><p><strong>可视化界面：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择图片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gui</span>():</span></span><br><span class="line">    root = tk.Tk()</span><br><span class="line">    root.title(<span class="string">&quot;eigenface&quot;</span>)</span><br><span class="line">    root.geometry(<span class="string">&#x27;500x300&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 点击选择图片时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">select</span>():</span></span><br><span class="line">        filename = tkinter.filedialog.askopenfilename()</span><br><span class="line">        <span class="keyword">if</span> filename != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            s = filename  <span class="comment"># 图片文件名 和 路径。</span></span><br><span class="line">            im = Image.<span class="built_in">open</span>(s)</span><br><span class="line">            tkimg = ImageTk.PhotoImage(im)  <span class="comment"># 执行此函数之前， Tk() 必须已经实例化。</span></span><br><span class="line">            l.config(image=tkimg)</span><br><span class="line">            btn1.config(command=<span class="keyword">lambda</span>: select2(filename))</span><br><span class="line">            btn1.config(text=<span class="string">&quot;开始识别&quot;</span>)</span><br><span class="line">            btn1.pack()</span><br><span class="line">            <span class="comment"># 重新绘制</span></span><br><span class="line">            root.mainloop()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">select2</span>(<span class="params">filename</span>):</span></span><br><span class="line">        btn1.pack_forget()</span><br><span class="line">        example(filename)</span><br><span class="line">        root.mainloop()</span><br><span class="line">    <span class="comment"># 显示图片的位置</span></span><br><span class="line">    btn = tk.Button(root, text=<span class="string">&quot;选择识别的图片&quot;</span>, command=select)</span><br><span class="line">    btn.pack()</span><br><span class="line"></span><br><span class="line">    btn1 = tk.Button(root)  <span class="comment"># 开始识别按钮，刚开始不显示</span></span><br><span class="line"></span><br><span class="line">    l = tk.Label(root)</span><br><span class="line">    l.pack()</span><br><span class="line">    root.mainloop()</span><br></pre></td></tr></table></figure>
<p> numpy 库可以很方便地计算两点$(x1, x2)$的距离，使用 numpy 中求范数的方法<code>np.linalg.norm</code>函数 实现:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.linalg.norm(x1-x2, <span class="built_in">ord</span>=<span class="literal">None</span>, axis=<span class="literal">None</span>, keepdims=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>其中各参数分别为（需要更改的是前两个）：</p>
<ul>
<li>x1-x2：两个点（向量）各个维度上的差</li>
<li>ord：求哪一种距离，对应 p p<em>p</em>，默认为 2(欧氏距离)</li>
<li>axis：取值 0 或 1，0 表示按列向量处理，求多个列向量的范数。默认为 0</li>
<li>keepding：是否保持矩阵的二维特性，默认为 False</li>
</ul>
<p>利用<code>np.linalg.norm</code>函数我们可以计算与被测人脸最相近的人脸库内的脸。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#加载数据集</span></span><br><span class="line">   eigenface = np.load(<span class="string">&#x27;data.npy&#x27;</span>)</span><br><span class="line"></span><br><span class="line">   mean = np.load(<span class="string">&#x27;mean.npy&#x27;</span>)</span><br><span class="line">   A=T-mean</span><br><span class="line">   _, trainNumber = np.shape(eigenface)</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 将训练集投影到特征脸上</span></span><br><span class="line">   projectedImage = eigenface.T* (A)</span><br><span class="line"></span><br><span class="line">   image = cv.imread(testImage, cv.IMREAD_GRAYSCALE)</span><br><span class="line">   shape = image.shape</span><br><span class="line">   </span><br><span class="line">   <span class="comment">#加载测试图</span></span><br><span class="line">   face_test = Face(testImage, testImage[<span class="number">0</span>:<span class="built_in">len</span>(testImage) - <span class="number">4</span>] + <span class="string">&quot;.txt&quot;</span>)</span><br><span class="line">   testImageArray = np.mat(np.array(face_test.transform()))</span><br><span class="line"></span><br><span class="line">   difference_img = testImageArray - mean</span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 识别</span></span><br><span class="line">   <span class="comment">#将测试图片投影到特征脸上</span></span><br><span class="line">   recongize_img = eigenface.T * (difference_img)</span><br><span class="line"></span><br><span class="line">   distance = []</span><br><span class="line">   <span class="comment">#计算训练集中人脸与被被测试人脸的差异度</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, trainNumber - <span class="number">1</span>):</span><br><span class="line">       q = projectedImage[:, i]</span><br><span class="line">       temp = np.linalg.norm(recongize_img - q)</span><br><span class="line">       distance.append(temp)</span><br><span class="line"></span><br><span class="line">   minDistance = <span class="built_in">min</span>(distance)</span><br><span class="line">   index = distance.index(minDistance)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">#输出识别结果图片</span></span><br><span class="line">   num = <span class="built_in">divmod</span>(index, file_num)[<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">   num0 = <span class="built_in">divmod</span>(index, file_num)[<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> num == <span class="number">41</span>:</span><br><span class="line">       result_img = cv.imread(<span class="string">&#x27;./AT&#x27;</span> + <span class="string">&#x27;/s&#x27;</span> + <span class="built_in">str</span>(num) + <span class="string">&#x27;/&#x27;</span> + <span class="built_in">str</span>(num0) + <span class="string">&#x27;.jpg&#x27;</span>, cv.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">       result_img = cv.imread(<span class="string">&#x27;./AT&#x27;</span> + <span class="string">&#x27;/s&#x27;</span> + <span class="built_in">str</span>(num) + <span class="string">&#x27;/&#x27;</span> + <span class="built_in">str</span>(num0) + <span class="string">&#x27;.pgm&#x27;</span>, cv.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line">   cv.imshow(<span class="string">&quot;result&quot;</span>, result_img)</span><br><span class="line">   <span class="comment">#保存被测图片的投影，便于重构</span></span><br><span class="line">   np.save(<span class="string">&quot;recongize.npy&quot;</span>,recongize_img)</span><br><span class="line">   <span class="keyword">return</span> recongize_img, shape, result_img</span><br></pre></td></tr></table></figure>
<h4 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h4><p>重构即识别的逆过程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">eigenface = np.load(<span class="string">&#x27;data.npy&#x27;</span>)</span><br><span class="line"></span><br><span class="line">   mean = np.load(<span class="string">&#x27;mean.npy&#x27;</span>)</span><br><span class="line">   face_num=<span class="number">10</span></span><br><span class="line">   recongize_img=np.load(<span class="string">&quot;recongize.npy&quot;</span>)</span><br><span class="line"></span><br><span class="line">   reconstruct = np.dot(eigenface , recongize_img)</span><br><span class="line">   reconstruct = reconstruct + mean</span><br><span class="line"></span><br><span class="line">   data_normal = cv.normalize(reconstruct, reconstruct, <span class="number">255</span>, <span class="number">0</span>, cv.NORM_MINMAX)</span><br><span class="line">   result = data_normal.reshape(IMAGE_SIZE)</span><br><span class="line">   result = np.uint8(result)</span><br><span class="line"></span><br><span class="line">   cv.imshow(<span class="string">&quot;restruction&quot;</span>,result)</span><br><span class="line">   cv.imwrite(<span class="string">&quot;restruction.jpg&quot;</span>,result)</span><br></pre></td></tr></table></figure>
<h2 id="实验结果分析"><a href="#实验结果分析" class="headerlink" title="实验结果分析"></a>实验结果分析</h2><hr>
<h4 id="平均脸与前十张特征脸"><a href="#平均脸与前十张特征脸" class="headerlink" title="平均脸与前十张特征脸"></a>平均脸与前十张特征脸</h4><center><img src="image-20201228201036283.png"></center><center><p>平均脸</p></center>

<p><strong>保存前十张特征脸的代码：</strong></p>
<p>使用numpy库内<code>hstack</code>函数拼接每张特征脸。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">img = eigenface[:, <span class="number">0</span>].reshape(IMAGE_SIZE)</span><br><span class="line">PCs=cv.normalize(img, <span class="literal">None</span>, <span class="number">255</span>, <span class="number">0</span>, cv.NORM_MINMAX, cv.CV_8UC1)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">    img=eigenface[:,i].reshape(IMAGE_SIZE)</span><br><span class="line">    img=cv.normalize(img, <span class="literal">None</span>, <span class="number">255</span>, <span class="number">0</span>, cv.NORM_MINMAX, cv.CV_8UC1)</span><br><span class="line">    PCs = np.hstack([PCs, img])</span><br><span class="line">    <span class="built_in">print</span>(PCs)</span><br><span class="line"></span><br><span class="line">PCs = np.uint8(PCs)</span><br><span class="line">cv.imwrite(<span class="string">&quot;PCs_10.jpg.jpg&quot;</span>, PCs)</span><br></pre></td></tr></table></figure>
<center><img src="PCs_10.jpg"  ></center>

<center>前十张特征脸</center>





<h4 id="重构自己人脸图像"><a href="#重构自己人脸图像" class="headerlink" title="重构自己人脸图像"></a>重构自己人脸图像</h4><p><img src="restruct.jpg" alt="restruct"></p>
<h4 id="Rank识别率"><a href="#Rank识别率" class="headerlink" title="Rank识别率"></a>Rank识别率</h4><p>实验中，使用一半人脸数据作为训练集，一半数据为测试集，测试PC值不同的时候的识别率。</p>
<p>其中，分别测试了PC值为20、50、100、150、200时的识别率。可以看出，随着PC值的增加，识别率逐步上升，当PC值在200时，识别率达到80%左右。</p>
<p><img src="image-20201229175923427.png" alt="image-20201229175923427"></p>
<h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><hr>
<p>这次实验原理比较数学，需要使用线性代数的知识，理解PCA中的降维的思想，通过转换基向量的形式使重要成分被当作向量的基向量，达到降维的目的，略有一些难度，需要多琢磨琢磨。</p>
<p>同时还发现一个问题是，当人脸集不进行预处理（即不进行人眼对齐）时，老师给的AT&amp;T训练集的识别率更高，识别率能达到90%以上。猜测应该是因为在人眼对齐的过程中，存在对图片的旋转、裁剪，从而造成了图片中黑边的存在，而黑边的位置和占比又会影响欧氏距离的计算，从而影响了识别结果，反而让识别率降低。由于时间有限，暂时没有对该现象进行解决。</p>

      
    </div>
    <footer class="article-footer">
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ComputerVision/" rel="tag">ComputerVision</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/opencv/" rel="tag">opencv</a></li></ul>

    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2021/01/29/echart1/" class="article-nav-link">
    <strong class="article-nav-caption">Newer</strong>
    <div class="article-nav-title">
      
      echart实现timeline+map+graph组合可视化图表
      
    </div>
  </a>
  
  
  <a href="/2021/01/28/cv_report2/" class="article-nav-link">
    <strong class="article-nav-caption">Older</strong>
    <div class="article-nav-title">opencv实现圆与直线的检测(Contour/line extraction)</div>
  </a>
  
</nav>

  

  
  
<div class="vcomments" id="vcomments"></div>

<script src="https://unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  new Valine({
    el: '#vcomments',
    appId: 'mfbB7edDpCCCx0ovfWDbEHTx-gzGzoHsz',
    appKey: '44y9taHcuYYfj5R9F9yTCMzu',
    notify: 'false',
    verify: 'true',
    avatar: 'mp',
    pageSize: '10',
    placeholder: '即刻评论，无需登录...'
  })
</script>

  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>Invictus maneo &copy; 2022</li>
      
        <li>京ICP备17054916号-2</li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="Invictus maneo"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">Gallery</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">categories</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">Tags</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/copybtn.js"></script>





<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>